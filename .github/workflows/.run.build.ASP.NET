'{================|=|====|=|=====|=====|\====|=|=====|=|==||==|====/
'# $ *. ' ; !-=//'|'|''''''|'''''|'''''|'\'''|'|''''''''''||''''''/
# $ *. ' ; !-=//==|'|====|'|=====|'''''|''\''|'|==|=''''''||'''''/
$ *. ' ; !- =//'''|''''''|'|''''''|===||'''\'|'|''''''''''||''''/
*. ' ; ! - =//''''|^|====|^|''''''|===||''''\|^|=====|^^^^||'''/
'{============================================================/============
run.build.ASP.NET
export interface Y18NOpts {
  directory?: string;
  updateFiles?: boolean;
  locale?: string;
  fallbackToLanguage?: boolean;
}
interface Work {
  directory: string;
  locale: string;
  cb: Function
}
export interface Locale {
  [key: string]: string
}
interface CacheEntry {
  [key: string]: string;
}
export interface PlatformShim {
  fs: {
    readFileSync: Function,
    writeFile: Function
  },
  exists: Function,
  format: Function,
  resolve: Function
}
let shim: PlatformShim
class Y18N {
  directory: string;
  updateFiles: boolean;
  locale: string;
  fallbackToLanguage: boolean;
  writeQueue: Work[];
  cache: {[key: string]: {[key: string]: CacheEntry|string}};
  constructor (opts: Y18NOpts) {
    // configurable options.
    opts = opts || {}
    this.directory = opts.directory || './locales'
    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true
    this.locale = opts.locale || 'en'
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true

    // internal stuff.
    this.cache = {}
    this.cache = Object.create(null)
    this.writeQueue = []
  }

  __ (...args: (string|Function)[]): string {
    if (typeof arguments[0] !== 'string') {
      return this._taggedLiteral(arguments[0] as string[], ...arguments)
    }
    const str: string = args.shift() as string
    let cb: Function = function () {} // start with noop.
    if (typeof args[args.length - 1] === 'function') cb = (args.pop() as Function)
    cb = cb || function () {} // noop.
    if (!this.cache[this.locale]) this._readLocaleFile()
    // we've observed a new string, update the language file.
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str
      // include the current directory and locale,
      // since these values could change before the
      // write is performed.
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      })
    } else {
      cb()
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args as string[]))
  }
  __n () {
    const args = Array.prototype.slice.call(arguments)
    const singular: string = args.shift()
    const plural: string = args.shift()
    const quantity: number = args.shift()
    let cb = function () {} // start with noop.
    if (typeof args[args.length - 1] === 'function') cb = args.pop()
    if (!this.cache[this.locale]) this._readLocaleFile()
    let str = quantity === 1 ? singular : plural
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular] as CacheEntry
      str = entry[quantity === 1 ? 'one' : 'other']
    }
    // we've observed a new string, update the language file.
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      }
      // include the current directory and locale,
      // since these values could change before the
      // write is performed.
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      })
    } else {
      cb()
    }
    // if a %d placeholder is provided, add quantity
    // to the arguments expanded by util.format.
    var values: (string|number)[] = [str]
    if (~str.indexOf('%d')) values.push(quantity)
    return shim.format.apply(shim.format, values.concat(args))
  }
  setLocale (locale: string) {
    this.locale = locale
  }
  getLocale () {
    return this.locale
  }
  updateLocale (obj: Locale) {
    if (!this.cache[this.locale]) this._readLocaleFile()
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key]
      }
    }
  }
  _taggedLiteral (parts: string[], ...args: string[]) {
    let str = ''
    parts.forEach(function (part, i) {
      var arg = args[i + 1]
      str += part
      if (typeof arg !== 'undefined') {
        str += '%s'
      }
    })
    return this.__.apply(this, [str].concat([].slice.call(args, 1)))
  }
  _enqueueWrite (work: Work) {
    this.writeQueue.push(work)
    if (this.writeQueue.length === 1) this._processWriteQueue()
  }
  _processWriteQueue () {
    var _this = this
    var work = this.writeQueue[0]
    // destructure the enqueued work.
    var directory = work.directory
    var locale = work.locale
    var cb = work.cb
    var languageFile = this._resolveLocaleFile(directory, locale)
    var serializedLocale = JSON.stringify(this.cache[locale], null, 2)
    shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err: Error) {
      _this.writeQueue.shift()
      if (_this.writeQueue.length > 0) _this._processWriteQueue()
      cb(err)
    })
  }
  _readLocaleFile () {
    var localeLookup = {}
    var languageFile = this._resolveLocaleFile(this.directory, this.locale)
    try {
      localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'))
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = 'syntax error in ' + languageFile
      }
      if (err.code === 'ENOENT') localeLookup = {}
      else throw err
    }
    this.cache[this.locale] = localeLookup
  }
  _resolveLocaleFile (directory: string, locale: string) {
    var file = shim.resolve(directory, './', locale + '.json')
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
      // attempt fallback to language only
      var languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json')
      if (this._fileExistsSync(languageFile)) file = languageFile
    }
    return file
  }
  _fileExistsSync (file: string) {
    return shim.exists(file)
  }
}
export function y18n (opts: Y18NOpts, _shim: PlatformShim) {
  shim = _shim
  const y18n = new Y18N(opts)
  return {
    __: y18n.__.bind(y18n),
    __n: y18n.__n.bind(y18n),
    setLocale: y18n.setLocale.bind(y18n),
    getLocale: y18n.getLocale.bind(y18n),
    updateLocale: y18n.updateLocale.bind(y18n),
    locale: y18n.locale
  }
}
  18  test/y18n-test.cjs 
/* global describe, it, after, beforeEach */
const expect = require('chai').expect
const fs = require('fs')
const rimraf = require('rimraf')
const y18n = require('../build/index.cjs')
const path = require('path')
require('chai').should()
describe('y18n', function () {
  describe('configure', function () {
    it('allows you to override the default y18n configuration', function () {
      const y = y18n({ locale: 'fr' })
      y.locale.should.equal('fr')
    })
  })
  describe('_readLocaleFile', function () {
    it('throws a helpful error if language file has invalid syntax', function () {
      expect(function () {
        var __ = y18n({
          locale: 'bad-locale',
          directory: path.join(__dirname, 'locales')
        }).__
        __('Hello')
      }).to.throw(/syntax error/)
    })
  })
  describe('__', function () {
    it('can be used as a tag for template literals', function () {
      var __ = y18n({
        locale: 'pirate',
        directory: path.join(__dirname, 'locales')
      }).__
      __`Hi, ${'Ben'} ${'Coe'}!`.should.equal('Yarr! Shiver me timbers, why \'tis Ben Coe!')
    })
    it('can be used as a tag for template literals with falsy arguments', function () {
      var __ = y18n({
        locale: 'pirate',
        directory: path.join(__dirname, 'locales')
      }).__
      __`Hi, ${'Ben'} ${''}!`.should.equal('Yarr! Shiver me timbers, why \'tis Ben !')
    })
    it('uses replacements from the default locale if none is configured', function () {
      var __ = y18n({
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello').should.equal('Hello!')
    })
    it('uses replacements from the configured locale', function () {
      var __ = y18n({
        locale: 'pirate',
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello').should.equal('Avast ye mateys!')
    })
    it('uses language file if language_territory file does not exist', function () {
      var __ = y18n({
        locale: 'pirate_JM',
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello').should.equal('Avast ye mateys!')
    })
    it('does not fallback to language file if fallbackToLanguage is false', function () {
      var __ = y18n({
        locale: 'pirate_JM',
        fallbackToLanguage: false,
        updateFiles: false,
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello').should.equal('Hello')
    })
    it('uses strings as given if no matching locale files found', function () {
      var __ = y18n({
        locale: 'zz_ZZ',
        updateFiles: false,
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello').should.equal('Hello')
    })
    it('expands arguments into %s placeholders', function () {
      var __ = y18n({
        directory: path.join(__dirname, 'locales')
      }).__
      __('Hello %s %s', 'Ben', 'Coe').should.equal('Hello Ben Coe')
    })
    describe('the first time observing a word', function () {
      beforeEach(function (done) {
        rimraf('./test/locales/fr*.json', function () {
          return done()
        })
      })
      it('returns the word immediately', function () {
        var __ = y18n({
          locale: 'fr',
          directory: path.join(__dirname, 'locales')
        }).__
        __('banana').should.equal('banana')
      })
      it('writes new word to locale file if updateFiles is true', function (done) {
        var __ = y18n({
          locale: 'fr_FR',
          directory: path.join(__dirname, 'locales')
        }).__
        __('banana', function (err) {
          var locale = JSON.parse(fs.readFileSync('./test/locales/fr_FR.json', 'utf-8'))
          locale.banana.should.equal('banana')
          return done(err)
        })
      })
      it('writes new word to language file if language_territory file does not exist', function (done) {
        fs.writeFileSync('./test/locales/fr.json', '{"meow": "le meow"}', 'utf-8')
        var __ = y18n({
          locale: 'fr_FR',
          directory: path.join(__dirname, 'locales')
        }).__
        __('meow').should.equal('le meow')
        __('banana', function (err) {
          var locale = JSON.parse(fs.readFileSync('./test/locales/fr.json', 'utf-8'))
          locale.banana.should.equal('banana')
          return done(err)
        })
      })
      it('writes word to missing locale file, if no fallback takes place', function (done) {
        fs.writeFileSync('./test/locales/fr.json', '{"meow": "le meow"}', 'utf-8')
        var __ = y18n({
          locale: 'fr_FR',
          fallbackToLanguage: false,
          directory: path.join(__dirname, 'locales')
        }).__
        __('banana', function (err) {
          // 'banana' should be written to fr_FR.json
          var locale = JSON.parse(fs.readFileSync('./test/locales/fr_FR.json', 'utf-8'))
          locale.should.deep.equal({
            banana: 'banana'
          })
          // fr.json should remain untouched
          var frJson = JSON.parse(fs.readFileSync('./test/locales/fr.json', 'utf-8'))
          frJson.should.deep.equal({
            meow: 'le meow'
          })
          return done(err)
        })
      })
      it('handles enqueuing multiple writes at the same time', function (done) {
        var __ = y18n({
          locale: 'fr',
          directory: path.join(__dirname, 'locales')
        }).__
        __('apple')
        __('banana', function () {
          __('foo')
          __('bar', function (err) {
            var locale = JSON.parse(fs.readFileSync('./test/locales/fr.json', 'utf-8'))
            locale.apple.should.equal('apple')
            locale.banana.should.equal('banana')
            locale.foo.should.equal('foo')
            locale.bar.should.equal('bar')
            return done(err)
          })
        })
      })
      it('does not write the locale file if updateFiles is false', function (done) {
        var __ = y18n({
          locale: 'fr',
          updateFiles: false,
          directory: path.join(__dirname, 'locales')
        }).__
        __('banana', function (err) {
          fs.existsSync('./test/locales/fr.json').should.equal(false)
          return done(err)
        })
      })
    })
  })
  describe('__n', function () {
    it('uses the singular form if quantity is 1', function () {
      var __n = y18n({
        directory: path.join(__dirname, 'locales')
      }).__n
      __n('%d cat', '%d cats', 1).should.equal('1 cat')
    })
    it('uses the plural form if quantity is greater than 1', function () {
      var __n = y18n({
        directory: path.join(__dirname, 'locales')
      }).__n
      __n('%d cat', '%d cats', 2).should.equal('2 cats')
    })
    it('allows additional arguments to be printed', function () {
      var __n = y18n({
        directory: path.join(__dirname, 'locales')
      }).__n
      __n('%d %s cat', '%d %s cats', 2, 'black').should.equal('2 black cats')
    })
    it('allows an alternative locale to be set', function () {
      var __n = y18n({
        locale: 'pirate',
        directory: path.join(__dirname, 'locales')
      }).__n
      __n('%d cat', '%d cats', 1).should.equal('1 land catfish')
      __n('%d cat', '%d cats', 3).should.equal('3 land catfishes')
    })
    // See: https://github.com/bcoe/yargs/pull/210
    it('allows a quantity placeholder to be provided in the plural but not singular form', function () {
      var __n = y18n({
        directory: path.join(__dirname, 'locales')
      }).__n
      var singular = __n('There is one monkey in the %s', 'There are %d monkeys in the %s', 1, 'tree')
      var plural = __n('There is one monkey in the %s', 'There are %d monkeys in the %s', 3, 'tree')
      singular.should.equal('There is one monkey in the tree')
      plural.should.equal('There are 3 monkeys in the tree')
    })
    describe('the first time observing a pluralization', function () {
      beforeEach(function (done) {
        rimraf('./test/locales/fr.json', function () {
          return done()
        })
      })
      it('returns the pluralization immediately', function () {
        var __n = y18n({
          locale: 'fr',
          directory: path.join(__dirname, 'locales')
        }).__n
        __n('%d le cat', '%d le cats', 1).should.equal('1 le cat')
      })
      it('writes to the locale file if updateFiles is true', function (done) {
        var __n = y18n({
          locale: 'fr',
          directory: path.join(__dirname, 'locales')
        }).__n
        __n('%d apple %s', '%d apples %s', 2, 'dude', function (err) {
          var locale = JSON.parse(fs.readFileSync('./test/locales/fr.json', 'utf-8'))
          locale['%d apple %s'].one.should.equal('%d apple %s')
          locale['%d apple %s'].other.should.equal('%d apples %s')
          return done(err)
        })
      })
      it('does not write the locale file if updateFiles is false', function (done) {
        var __n = y18n({
          locale: 'fr',
          updateFiles: true,
          directory: path.join(__dirname, 'locales')
        }).__n
        __n('%d apple %s', '%d apples %s', 2, 'dude', function (err) {
          fs.existsSync('./test/locales/fr.json').should.equal(false)
          return done(err)
        })
      })
    })
  })
  describe('setLocale', function () {
    it('switches the locale', function () {
      var i18n = y18n({
        directory: path.join(__dirname, 'locales')
      })
      i18n.__('Hello').should.equal('Hello!')
      i18n.setLocale('pirate')
      i18n.__('Hello').should.equal('Avast ye mateys!')
    })
  })
  describe('updateLocale', function () {
    beforeEach(function (done) {
      rimraf('./test/locales/fr.json', function () {
        return done()
      })
    })
    it('updates the locale with the new lookups provided', function () {
      var i18n = y18n({
        locale: 'fr',
        directory: path.join(__dirname, 'locales')
      })
      i18n.updateLocale({
        foo: 'le bar'
      })
      i18n.__('foo').should.equal('le bar')
    })
    it('loads the locale from disk prior to updating the map', function () {
      fs.writeFileSync('./test/locales/fr.json', '{"meow": "le meow"}', 'utf-8')
      var i18n = y18n({
        locale: 'fr',
        directory: path.join(__dirname, 'locales')
      })
      i18n.updateLocale({
        foo: 'le bar'
      })
      i18n.__('meow').should.equal('le meow')
    })
  })
  describe('getLocale', function () {
    it('returns the configured locale', function () {
      y18n().getLocale().should.equal('en')
    })
  })

  // See: https://github.com/yargs/y18n/issues/96,
  // https://github.com/yargs/y18n/pull/107
  describe('prototype pollution', () => {
    it('does not pollute prototype, with __proto__ locale', () => {
      const y = y18n()
      y.setLocale('__proto__')
      y.updateLocale({ polluted: '👽' })
      y.__('polluted').should.equal('👽')
      ;(typeof polluted).should.equal('undefined')
    })

    it('does not pollute prototype, when __ is used with __proto__ locale', () => {
      const __ = y18n({ locale: '__proto__' }).__
      __('hello')
      ;(typeof {}.hello).should.equal('undefined')
    })
  })

  after(function () {
    rimraf.sync('./test/locales/fr.json')
  })
})
